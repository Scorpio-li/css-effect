<!--
 * @Author: Li Zhiliang
 * @Date: 2020-11-24 16:38:10
 * @LastEditors: Li Zhiliang
 * @LastEditTime: 2020-11-24 17:27:39
 * @FilePath: /Canvas/docs/canvas/ball/index2.html
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¼˜åŒ–ç‰ˆæœ¬</title>
    <style>
        html,
        body,
        canvas {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <script>
        // js ç‰ˆæœ¬çš„è®¡ç®—ä¸¤ç‚¹è·ç¦»å…¬å¼
        function twoPointDistance(p1, p2) {
            let distance = Math.sqrt(Math.pow((p1.x - p2.x), 2) + Math.pow((p1.y - p2.y), 2));
            return distance;
        }
        // æ­å»ºhtmlæ¨¡ç‰ˆï¼Œåˆå§‹åŒ–canvasç”»å¸ƒã€ç”»ç¬”
        window.onload = () => {
                const canvas = document.getElementById('canvas');
                // ä¸–ç•Œæœ‰å¤šå¤§èˆå°å°±è¦æœ‰å¤šå¤§ğŸ˜„
                // psï¼š è¿™é‡Œçš„å®½é«˜ä¸æ˜¯cssæ ·å¼å±‚é¢çš„å®½é«˜ï¼Œæ˜¯åƒç´ ç‚¹å“¦
                canvas.width = window.document.body.clientWidth;
                canvas.height = window.document.body.clientHeight;
                const ctx = canvas.getContext('2d');

                // å¤šçƒè¿åŠ¨
                const num = 100;
                let balls = []
                    // å¤šå§¿å¤šå½©
                const colors = ['#66cccc', '#ccff66', '#ff99cc', '#ff9999', '#666699', '#ff0033', '#FFF2B0'];
                // æˆ‘è¦100ä¸ª
                for (let i = 0; i < num; i++) {
                    balls.push(new Ball({
                        ctx,
                        // éšæœºå‡ºç°åœ¨ç”»å¸ƒä¸­ä»»ä½•ä¸€å¤„
                        x: Math.floor(Math.random() * ctx.canvas.width),
                        y: Math.floor(Math.random() * ctx.canvas.height),
                        radius: 10,
                        color: colors[Math.floor(Math.random() * 7)]
                    }))
                }

                // å°†ç‚¹ä¹‹é—´æ·»åŠ è¿çº¿
                let delayTime = 0;
                // ä¸Šä¸€å¸§çš„æ—¶é—´
                let lastTime = +new Date;

                // å¾ªç¯ç»˜ç”»
                const loopDraw = () => {
                    requestAnimationFrame(loopDraw);
                    // å½“å‰æ—¶é—´
                    const now = +new Date;
                    delayTime = now - lastTime;
                    lastTime = now;
                    if (delayTime > 50) delayTime = 50;
                    // ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    // æ›¿æ¢clearRect, ä½¿ä¸Šä¸€æ¬¡çš„æ•ˆæœé€æ˜åº¦å˜æˆ0.3
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    balls.forEach((ball, index) => {
                        ball.render();
                        // æ ¹æ®æ—¶é—´åœ¨updataä¸­è°ƒæ•´å¢é‡
                        ball.updata(delayTime && delayTime);
                        balls.forEach(ball2 => {
                            const distance = twoPointDistance(ball, ball2)
                                // æ’é™¤è‡ªå·±å’Œ100åƒç´ å¼€å¤–çš„
                            if (distance && distance < 100) {
                                ball.renderLine(ball2)
                            }
                        })
                    })
                }

                loopDraw(); // æ»´æ»´å¯åŠ¨åŠ¨ç”»
            }
            // å®šä¹‰ä¸€ä¸ªBallç±»
        class Ball {
            // åˆå§‹åŒ–çš„ç‰¹å¾
            constructor(options = {}) {
                    const {
                        x = 0, // xåæ ‡
                            y = 0, // yåæ ‡
                            ctx = null, // ç¥å¥‡çš„ç”»ç¬”ğŸ–Œï¸
                            radius = 0, // çƒçš„åŠå¾„
                            color = '#000' // é¢œè‰²
                    } = options
                    this.x = x;
                    this.y = y;
                    this.ctx = ctx;
                    this.radius = radius;
                    this.color = color;

                    // é€Ÿåº¦: å¤šçƒè¿åŠ¨
                    this.vx = (Math.random() - 0.5) * 10;
                    this.vy = (Math.random() - 0.5) * 10;
                    // åŠ é€Ÿåº¦
                    this.gvx = (Math.random() - 0.5) * 0.01;
                    this.gvy = (Math.random() - 0.5) * 0.01;
                }
                // æ¸²æŸ“
            render() {
                    this.ctx.beginPath();
                    this.ctx.fillStyle = this.color;
                    // ç”»åœ†
                    this.ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI)
                    this.ctx.fill()
                }
                // è®©çƒåšæ— é‡åŠ›è¿åŠ¨
            updata(delayTime) {
                    // this.x += this.vx;
                    // this.y += this.vy;
                    // æ¯ä¸€å¸§çš„æ—¶é—´éƒ½ä¸ä¸€æ ·ï¼Œ é‚£ä¹ˆä½¿ç”¨æ¯ä¸€æ¯«ç§’
                    this.x += this.vx / (delayTime || 1) * 3;
                    this.y += this.vy / (delayTime || 1) * 3;
                    this.vy += this.gvy;
                    this.vx += this.gvx;
                    // è§¦é¡¶
                    if (this.y - this.radius <= 0) {
                        this.y = this.radius
                        this.vy = -this.vy * 0.99 // éš
                    }
                    // è§¦åº•
                    if (this.y >= this.ctx.canvas.height - this.radius) {
                        if (this.vy <= this.gvy * 2 + this.vy * 0.8) this.vy = 0;
                        this.y = this.ctx.canvas.height - this.radius;
                        this.vy = -this.vy * 0.75; // ä¾¿
                    }
                    //  è§¦å³
                    if (this.x - this.radius <= 0) {
                        this.x = this.radius
                        this.vx = -this.vx * 0.5 // è®¾
                    }
                    // è§¦å·¦
                    if (this.x + this.radius >= this.ctx.canvas.width) {
                        this.x = this.ctx.canvas.width - this.radius
                        this.vx = -this.vx * 0.5 // ç½®
                    }
                }
                // æ·»åŠ è¿çº¿
            renderLine(target) {
                // æ¸å˜è‰²ï¼Œç”±æˆ‘å’Œtargetç»„æˆ
                let lingrad = this.ctx.createLinearGradient(this.x, this.y, target.x, target.y);
                lingrad.addColorStop(0, this.color);
                lingrad.addColorStop(1, target.color);

                this.ctx.beginPath();
                // this.ctx.strokeStyle = "ddd";
                this.ctx.strokeStyle = lingrad;
                this.ctx.moveTo(this.x, this.y);
                this.ctx.lineTo(target.x, target.y);
                this.ctx.stroke();
            }

            // æ·»åŠ ä¸ªåœˆ
            renderCircle(target, radius) {
                this.ctx.beginPath();
                this.ctx.strokeStyle = this.color;
                this.ctx.arc((this.x + target.x) / 2, (this.y + target.y) / 2, radius, 0, 2 * Math.PI);
                this.ctx.stroke();
            }
        }
    </script>
</body>

</html>